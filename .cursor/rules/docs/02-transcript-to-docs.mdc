---
description: Convert transcripts + source code into engaging, sourceâ€‘backed docs with consistent structure, tone, and examples.
alwaysApply: false
---

# Rule: Transcript to Documentation

Purpose: Transform technical transcripts and source code into comprehensive, engaging documentation for Planton Cloud features. Use this when creating documentation for new platform sections based on recorded explanations.

**âš ï¸ CRITICAL: Only document features that actually exist. Never make up commands, features, or capabilities. If it's not in the source code or transcripts, DO NOT include it.**

Usage: Invoke explicitly as `@transcript-to-docs` when you have a transcript explaining a feature/concept and need to create full documentation.

Dependencies:
- `@docs-style` â€” Style and tone guidelines for docs/blogs
- `@docs-sources` â€” Source-of-truth and referencing requirements

## Process Overview
1. Analyze the transcript: extract key concepts, technical details, narrative flow
2. Research source code: read protobufs, services, and CLI to validate behavior
3. **CRITICAL**: Verify every feature, command, and capability exists in source code
4. Create documentation structure: multiple interconnected pages
5. Write human-friendly content: translate technical detail into approachable explanations

## Documentation Requirements

### CRITICAL: Source Verification Requirements
**NEVER MAKE UP FEATURES, COMMANDS, OR CAPABILITIES**

Before documenting ANY feature:
1. **Commands**: Search for the exact command in `planton-cloud/client-apps/cli`. If not found, DO NOT include it.
2. **API Operations**: Verify in protobuf definitions. If the RPC/field doesn't exist, DO NOT document it.
3. **Features**: Check transcripts, backend services, and APIs. If not explicitly mentioned or implemented, DO NOT add it.
4. **Configuration Options**: Only document fields that exist in the protobuf specs.

**When in doubt, OMIT rather than ASSUME**. It's better to have less documentation than wrong documentation.

Examples of what NOT to do:
- Don't invent CLI commands like `planton infra import` if they don't exist
- Don't add features like "drift detection" unless found in source
- Don't assume credential types like "assume role" exist without verification
- Don't create sections about performance optimization unless documented
- Don't add "nice to have" features that aren't implemented

### Tone and Style
- Conversational and direct; write as if explaining to a colleague
- Developerâ€‘first analogies (e.g., Vercel, Heroku) when useful
- Actionâ€‘oriented: focus on what users can do
- Balanced voice: approachable, not robotic; avoid pure bullet dumps
- Examplesâ€‘heavy: show, donâ€™t just tell

### Content Structure (by section)
1) Index page (`feature-name/index.mdx`)
   - Highâ€‘level overview and value proposition
   - Visual organization of subâ€‘topics and clear navigation
   - â€œWhy this mattersâ€ section

2) Concept page (`feature-name/what-is-x.mdx`)
   - Deep dive into the core concept with relatable analogies
   - Technical details in plain language
   - Configuration examples and common patterns

3) Getting started (`feature-name/getting-started.mdx`)
   - 5â€‘minute quickâ€‘start promise
   - Stepâ€‘byâ€‘step walkthrough
   - Multiâ€‘language/framework examples
   - Troubleshooting for common issues

4) Deep dives (e.g., `pipelines.mdx`, `configuration.mdx`)
   - Advanced features, performance tips, best practices

### Markdown Format
Use standard Markdown (no React components):
```markdown
# Headings with personality

> **Note:** Use blockquotes for callouts

### Use emoji headers sparingly but effectively ğŸš€

**Bold for emphasis** | **Pipes for compact badges**

- Lists for features
- Not walls of text

```yaml
# Realistic, copyâ€‘pastable examples everywhere
name: real-examples
```
```

### Creating Engaging Content
1. Start with why (why this matters) before what/how
2. Use analogies (â€œThink of X like Vercel, but for Yâ€)
3. Show progress (â€œBy the end of this guide, youâ€™ll haveâ€¦â€) 
4. Address pain points (â€œPreviouslyâ€¦ now you justâ€¦â€) 
5. Celebrate simplicity (â€œPush code, get deployments.â€)

## Implementation Checklist
- [ ] Extract key concepts and make a concept map FROM TRANSCRIPTS ONLY
- [ ] Research implementation in source code:
  - Backend: `planton-cloud/backend/services/<feature-name>`
  - APIs: `planton-cloud/apis/cloud/planton/<domain>`
  - CLI: `planton-cloud/client-apps/cli/cmd/planton/root/<feature>`
- [ ] **VERIFY each feature exists**:
  - [ ] Every CLI command: grep for it in CLI source
  - [ ] Every API operation: find it in protobufs
  - [ ] Every configuration option: locate in spec.proto
  - [ ] Every workflow: trace through backend implementation
- [ ] Create structure: index â†’ concept â†’ gettingâ€‘started â†’ deepâ€‘dives
- [ ] Write content that:
  - Uses transcript as foundation
  - **ONLY includes verified features from source**
  - Includes YAML/code snippets **copied from actual examples**
  - Provides troubleshooting tips **based on actual error handling**
- [ ] Final verification pass:
  - [ ] Re-check every command against CLI source
  - [ ] Validate every YAML example against protobufs
  - [ ] Remove any speculative or "would be nice" content
- [ ] Ensure navigation works:
  - Frontmatter (title, description, icon, order)
  - Directories with `index.mdx` are clickable
  - No duplicate sidebar entries

## Example Transformation
From transcript:
> â€œA service in PlantonCloud is an API aimed at providing users to bring their git repositoriesâ€¦â€

To documentation:
> Remember the first time you pushed code to Vercel and watched it automatically build and deploy? That magical feeling is what weâ€™re bringing to all your backend servicesâ€¦

## Key Patterns to Follow
1. Monorepo examples: always include simple + monorepo configs (if supported in source)
2. Visual organization: headers/spacing for scannability
3. Progressive disclosure: start simple, add complexity (with real features only)
4. Real configuration: use actual protobuf field names (copy exactly from proto files)
5. CLI examples: include ONLY commands that exist in CLI source code
6. Every example must be verifiable: reader should be able to run it successfully

## Antiâ€‘Patterns to Avoid
- **DON'T MAKE UP FEATURES OR COMMANDS** - This is the #1 rule
- Don't invent "logical" features that "should" exist but aren't implemented
- Don't add aspirational content about future capabilities
- Don't extrapolate features from similar products
- Don't use React components (Callout, Card, Tabs, etc.)
- Don't create walls of dense technical text
- Don't assume deep DevOps knowledge
- Don't skip "why" to rush to "how"
- Don't omit concrete examples (but only use real ones)

## Source Validation (MANDATORY)
**Every single claim must be traceable to source code or transcripts**

Required verification:
- **CLI Commands**: Must exist in `planton-cloud/client-apps/cli/cmd/planton/root/`
  - Use grep/search to find exact command implementation
  - If command not found = DO NOT DOCUMENT IT
- **API Fields**: Must exist in protobuf definitions
  - Check exact field names and types
  - No guessing at field names or options
- **Features/Workflows**: Must be in transcripts OR implemented in backend
  - Trace through actual service code
  - Look for the exact feature, not similar ones
- **Configuration Examples**: Must match protobuf schemas exactly
  - Copy field names verbatim
  - Don't add "helpful" extra fields

Reference pattern (include these in docs):
```
Based on: `planton-cloud/backend/services/service-hub/...`
API: `planton-cloud/apis/ai/planton/servicehub/service/v1/spec.proto`
Transcript: `websites/kb.planton.cloud/content/product/service-hub/transcripts/...`
```

**If you cannot find source evidence for a feature, it MUST be omitted**

## When Features Are Not Found in Sources
If a feature seems logical or is mentioned vaguely but you cannot find concrete implementation:
1. **DO NOT INCLUDE IT** - No exceptions
2. **DO NOT** write "Coming soon" or "Future capability"
3. **DO NOT** extrapolate from similar features
4. **DO** focus on what IS implemented and documented
5. **DO** make the existing features shine with good examples

Remember: Incomplete but accurate docs > Complete but inaccurate docs

## Final Quality Check
- [ ] **Every feature documented exists in source code** â† CRITICAL
- [ ] **Every command shown works when executed** â† CRITICAL
- [ ] **Every YAML example matches protobuf schemas** â† CRITICAL
- [ ] Clear to a developer new to the platform?
- [ ] Enough copyâ€‘pastable examples? (from real sources only)
- [ ] Addresses common pain points? (mentioned in transcripts)
- [ ] Friendly but professional tone?
- [ ] All claims backed by source code with explicit references?

## Summary
This rule ensures accurate documentation by:
1) **ONLY documenting features that exist in source code or transcripts**
2) Translating transcripts into humanâ€‘friendly explanations
3) Creating interconnected pages (index, concept, gettingâ€‘started, deepâ€‘dives)
4) Using a conversational tone with verified examples only
5) Grounding EVERYTHING in source - no assumptions or extrapolations
6) Using standard Markdown (no React components)
7) Making complex topics accessible without inventing features

**Core principle: If it's not in the source, it's not in the docs.**
